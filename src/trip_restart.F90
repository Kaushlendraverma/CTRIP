!TRP_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!TRP_LIC This is part of the CTRIP software governed by the CeCILL-C licence
!TRP_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!TRP_LIC for details. version 1.
!#########
SUBROUTINE TRIP_RESTART (TP, TPG, TPLK, TPST, &
                         KLISTING,KYEAR,KMONTH,KDAY,PTIME,KLON,KLAT,KLAKE_NUM)
!############################################
!
!!****  *TRIP_RESTART*
!!
!!    PURPOSE
!!    -------
!
!     TRIP river routing restart.
!
!!
!!    AUTHOR
!!    ------
!!      B. Decharme
!!
!!    MODIFICATIONS
!!    -------------
!!      Original    28/05/05
!!      S. Munier   28/03/2020 CTRIP-12D and parallelization
!!      T. Guinaldo 04/2020    Add MLake
!-------------------------------------------------------------------------------
!
!*       0.     DECLARATIONS
!               ------------
!
!
USE MODD_TRIP, ONLY : TRIP_t
USE MODD_TRIP_GRID, ONLY : TRIP_GRID_t
USE MODD_TRIP_LAKE, ONLY : TRIP_LAKE_t
USE MODD_TRIP_STATE, ONLY : TRIP_STATE_t
!
USE MODD_TRIP_MPI
!
USE MODN_TRIP,      ONLY : CGROUNDW, LFLOOD, CLAKE
!
USE MODE_RW_TRIP
USE MODE_TRIP_GRID_STATE, ONLY : TRIP_STATE_TO_GRID
USE MODE_TRIP_LAKE, ONLY : TRIP_STATE_TO_LAKE
!
USE MODI_WAITING_MPI
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
IMPLICIT NONE
!
#ifdef SFX_MPI
INCLUDE "mpif.h"
#endif
!
!*      0.1    declarations of arguments
!
!
TYPE(TRIP_t),       INTENT(INOUT) :: TP
TYPE(TRIP_GRID_t),  INTENT(INOUT) :: TPG
TYPE(TRIP_LAKE_t),  INTENT(INOUT) :: TPLK
TYPE(TRIP_STATE_t), INTENT(INOUT) :: TPST
!
INTEGER,            INTENT(IN)    :: KLISTING
INTEGER,            INTENT(IN)    :: KYEAR
INTEGER,            INTENT(IN)    :: KMONTH
INTEGER,            INTENT(IN)    :: KDAY
REAL,               INTENT(IN)    :: PTIME
INTEGER,            INTENT(IN)    :: KLON
INTEGER,            INTENT(IN)    :: KLAT
INTEGER,            INTENT(IN)    :: KLAKE_NUM
!
!*      0.2    declarations of local variables
!
LOGICAL,           PARAMETER :: LDOUBLE=.TRUE.
!
CHARACTER(LEN=25)            :: YFILE ='TRIP_RESTART.nc'
CHARACTER(LEN=20)            :: YVNAME
!
LOGICAL, DIMENSION(:,:), ALLOCATABLE :: LMASK
LOGICAL, DIMENSION(:,:), ALLOCATABLE :: LMASK_GW
LOGICAL, DIMENSION(:),   ALLOCATABLE :: LMASK_LAKE
!
INTEGER :: ISTATE   !size of the proc state vector
REAL, DIMENSION(:), ALLOCATABLE   :: ZSTATE
!
INTEGER :: IERR
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
!-------------------------------------------------------------------------------
!
! * Store output in diag file
!
IF (LHOOK) CALL DR_HOOK('TRIP_RESTART',0,ZHOOK_HANDLE)
!
! * Current date
!
IF (NRANK==NPIO) CALL WRITE_TRIP_DATE(KLISTING,YFILE,KYEAR,KMONTH,KDAY,PTIME)
!
! * Allocate masks
!
IF (NRANK==NPIO) THEN
  ALLOCATE(LMASK(KLON,KLAT))
  LMASK(:,:) = TPG%GMASK(:,:)
!
  IF (CGROUNDW/='DEF') THEN
    ALLOCATE(LMASK_GW(KLON,KLAT))
    LMASK_GW(:,:) = TPG%GMASK_GW(:,:)
  ENDIF
!
  IF (CLAKE=='MLK') THEN
    ALLOCATE(LMASK_LAKE(KLAKE_NUM))
    LMASK_LAKE(:) = .TRUE.
  ENDIF
ENDIF
!
IF (NRANK==NPIO) THEN
  ALLOCATE(ZSTATE(TPST%NNSTATE))
ELSE
  ALLOCATE(ZSTATE(0))
ENDIF
ISTATE = TPST%NNSTATE_P
!
CALL WAITING_MPI('TRIP_RESTART')
!
! * Write variables
!
YVNAME = 'SURF_STO'
CALL MPI_GATHER(TPST%XSURF_STO,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XSURF_STO)
IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK,TP%XSURF_STO,ODOUBLE=LDOUBLE)
!
IF(CLAKE=='MLK')THEN
  YVNAME = 'LAKE_STO'
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_LAKE(TPST%NLAKE_STATE,ZSTATE,TPLK%XLAKE_STO)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK_LAKE,TPLK%XLAKE_STO)
ENDIF
!
IF(CGROUNDW=='CST')THEN
  YVNAME = 'GROUND_STO'
  CALL MPI_GATHER(TPST%XGROUND_STO,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XGROUND_STO)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK_GW,TP%XGROUND_STO,ODOUBLE=LDOUBLE)
ELSEIF(CGROUNDW=='DIF')THEN
  YVNAME = 'HGROUND'
  CALL MPI_GATHER(TPST%XHGROUND,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XHGROUND)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK_GW,TP%XHGROUND,ODOUBLE=LDOUBLE)
ENDIF
!
IF(LFLOOD)THEN
  YVNAME = 'FLOOD_STO'
  CALL MPI_GATHER(TPST%XFLOOD_STO,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XFLOOD_STO)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK,TP%XFLOOD_STO,ODOUBLE=LDOUBLE)
  YVNAME = 'FFLOOD'
  CALL MPI_GATHER(TPST%XFFLOOD,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XFFLOOD)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK,TP%XFFLOOD,ODOUBLE=LDOUBLE)
  YVNAME = 'HFLOOD'
  CALL MPI_GATHER(TPST%XHFLOOD,ISTATE,MPI_DOUBLE,ZSTATE,ISTATE,MPI_DOUBLE,NPIO,NCOMM,IERR)
  IF (NRANK==NPIO) CALL TRIP_STATE_TO_GRID(TPST%NSTATE_LON,TPST%NSTATE_LAT,ZSTATE,TP%XHFLOOD)
  IF (NRANK==NPIO) CALL WRITE_TRIP(KLISTING,YFILE,YVNAME,LMASK,TP%XHFLOOD,ODOUBLE=LDOUBLE)
ENDIF
!
IF (NRANK==NPIO) THEN
  DEALLOCATE(LMASK)
  IF (CGROUNDW/='DEF') DEALLOCATE(LMASK_GW)
  IF (CLAKE=='MLK') DEALLOCATE(LMASK_LAKE)
ENDIF
DEALLOCATE(ZSTATE)
!
IF (LHOOK) CALL DR_HOOK('TRIP_RESTART',1,ZHOOK_HANDLE)
!
!-------------------------------------------------------------------------------
END SUBROUTINE TRIP_RESTART
