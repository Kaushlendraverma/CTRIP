!TRP_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!TRP_LIC This is part of the CTRIP software governed by the CeCILL-C licence
!TRP_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!TRP_LIC for details. version 1.
SUBROUTINE TRIP_BASIN_PROC(TPG,TPLK,TPST,KLISTING,KLON,KLAT,KLAKE_NUM)
!#############################################
!
!!****  *TRIP_BASIN_PROC*
!!
!!    PURPOSE
!!    -------
!!
!!    Assign basins to procs
!!
!!    REFERENCE
!!    ---------
!!
!!    AUTHOR
!!    ------
!!      S. Munier
!!
!!    MODIFICATIONS
!!    -------------
!!      Original    07/19
!!      T. Guinaldo 04/2020    Add MLake
!-------------------------------------------------------------------------------
!
!*       0.     DECLARATIONS
!               ------------
!
USE MODD_TRIP_MPI
USE MODD_TRIP_GRID,  ONLY : TRIP_GRID_t
USE MODD_TRIP_LAKE,  ONLY : TRIP_LAKE_t
USE MODD_TRIP_STATE, ONLY : TRIP_STATE_t
!
USE MODN_TRIP, ONLY : CLAKE
!
USE MODI_WAITING_MPI
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
IMPLICIT NONE
!
#ifdef SFX_MPI
INCLUDE "mpif.h"
#endif
!
!-------------------------------------------------------------------------------
!
!*      0.1    declarations of arguments
!
!
TYPE(TRIP_GRID_t),  INTENT(INOUT) :: TPG
TYPE(TRIP_LAKE_t),  INTENT(INOUT) :: TPLK
TYPE(TRIP_STATE_t), INTENT(INOUT) :: TPST
INTEGER,            INTENT(IN)    :: KLISTING
INTEGER,            INTENT(IN)    :: KLON          ! Number of longitude
INTEGER,            INTENT(IN)    :: KLAT          ! Number of latitude
INTEGER,            INTENT(IN)    :: KLAKE_NUM     ! Number of lakes
!
!-------------------------------------------------------------------------------
!
!*      0.2    declarations of local variables
!
INTEGER, ALLOCATABLE, DIMENSION(:) :: IBASCELLS           ! Number of cells within each basin
INTEGER, ALLOCATABLE, DIMENSION(:) :: IPROCCELLS          ! Number of cells per proc
INTEGER, ALLOCATABLE, DIMENSION(:) :: IBASPROC            ! Proc of each basin
INTEGER, ALLOCATABLE, DIMENSION(:) :: ISTATE_LON_TMP      ! Longitude of state members
INTEGER, ALLOCATABLE, DIMENSION(:) :: ISTATE_LAT_TMP      ! Latitude of state members
INTEGER                            :: INCELLS
INTEGER :: JLON,JLAT,IBAS,JPROC,JSEQ,JNUM,JSTATE
INTEGER :: IPROCCELLS_MIN
LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: LLAKE_OUT
!
INTEGER :: IERR
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
! --------------------------------------------------------------------------------------
! * 1. Assign basins to procs
! --------------------------------------------------------------------------------------
!
IF (LHOOK) CALL DR_HOOK('TRIP_BASIN_PROC',0,ZHOOK_HANDLE)
!
ALLOCATE(TPST%NSTATE_LEN(0:NPROC-1))
ALLOCATE(TPST%NSTATE_POS(0:NPROC-1))
ALLOCATE(TPST%NSTATE_IND_P(KLON,KLAT))
IF(CLAKE=='MLK'.AND.NRANK==NPIO)THEN
  ALLOCATE(TPST%NLAKE_STATE(TPLK%NLAKE_NUM))
ELSE
  ALLOCATE(TPST%NLAKE_STATE(0))
  ALLOCATE(TPST%NSTATE_IND(0,0))
  ALLOCATE(TPST%NSTATE_LON(0))
  ALLOCATE(TPST%NSTATE_LAT(0))
ENDIF
!
IF (NRANK==NPIO) THEN
  IBAS = MAXVAL(TPG%NBASID)
  ALLOCATE(IBASCELLS(IBAS))
  IBASCELLS(:) = 0
  ALLOCATE(LLAKE_OUT(KLON,KLAT))
  LLAKE_OUT = .TRUE.
  !
  ! 1.1. Count number of cells for each basin
  DO JLAT=1,KLAT
    DO JLON=1,KLON
      IF (CLAKE=='MLK') THEN
        LLAKE_OUT(JLON,JLAT) = TPG%GMASK_LAKE_NW(JLON,JLAT)
        IF(TPG%NGRCN(JLON,JLAT)>=1.AND.TPG%NGRCN(JLON,JLAT)<=8) &
          LLAKE_OUT(JLON,JLAT) = LLAKE_OUT(JLON,JLAT).AND. &
          TPLK%NLAKE_ID_NW(JLON,JLAT)/=TPLK%NLAKE_ID_NW(TPG%NNEXTX(JLON,JLAT),TPG%NNEXTY(JLON,JLAT))
      ENDIF
      IF (TPG%NBASID(JLON,JLAT) > 0 .AND. &
          (.NOT.TPG%GMASK_LAKE_NW(JLON,JLAT) .OR. LLAKE_OUT(JLON,JLAT))) THEN
        IBASCELLS(TPG%NBASID(JLON,JLAT)) = IBASCELLS(TPG%NBASID(JLON,JLAT))+1
      ENDIF
    ENDDO
  ENDDO
  !
  ! 1.2. Assign proc for each basin
  INCELLS = SUM(IBASCELLS)
  ALLOCATE(IPROCCELLS(0:NPROC-1))
  ALLOCATE(IBASPROC(IBAS))
  ALLOCATE(ISTATE_LON_TMP(INCELLS))
  ALLOCATE(ISTATE_LAT_TMP(INCELLS))
  IPROCCELLS(:) = 0
  IBASPROC(:) = -1
  JSEQ = TPG%NSEQMAX
  JPROC = 0
  IPROCCELLS_MIN = 0
  JNUM = INCELLS
  DO WHILE (JSEQ>0)
    DO JLAT=KLAT,1,-1
      DO JLON=KLON,1,-1
        IF (TPG%NBASID(JLON,JLAT)==0 .OR. TPG%NSEQ(JLON,JLAT)/=JSEQ .OR. &
            (TPG%GMASK_LAKE_NW(JLON,JLAT) .AND. .NOT.LLAKE_OUT(JLON,JLAT))) CYCLE
        IF (IBASPROC(TPG%NBASID(JLON,JLAT))==-1) THEN
          DO WHILE (IPROCCELLS(JPROC)/=IPROCCELLS_MIN .OR. (NPROC>1.AND.JPROC==0))
            JPROC = MOD(JPROC+1,NPROC)
          ENDDO
          IBASPROC(TPG%NBASID(JLON,JLAT)) = JPROC
          IPROCCELLS(JPROC) = IPROCCELLS(JPROC)+IBASCELLS(TPG%NBASID(JLON,JLAT))
          IPROCCELLS_MIN = IPROCCELLS(0)
          IF (NPROC>1) IPROCCELLS_MIN = MINVAL(IPROCCELLS(1:NPROC-1))
        ENDIF
        ISTATE_LON_TMP(JNUM) = JLON
        ISTATE_LAT_TMP(JNUM) = JLAT
        JNUM = JNUM-1
      ENDDO
    ENDDO
    JSEQ = JSEQ-1
  ENDDO
  !
  ! 1.3. Create state vector
  TPST%NNSTATE_P = MAXVAL(IPROCCELLS)
  DO JPROC = 0,NPROC-1
    TPST%NSTATE_POS(JPROC) = TPST%NNSTATE_P*JPROC+1
    TPST%NSTATE_LEN(JPROC) = IPROCCELLS(JPROC)
  ENDDO
  !
  TPST%NNSTATE = TPST%NNSTATE_P*NPROC
  ALLOCATE(TPST%NSTATE_IND(KLON,KLAT))
  ALLOCATE(TPST%NSTATE_LON(TPST%NNSTATE))
  ALLOCATE(TPST%NSTATE_LAT(TPST%NNSTATE))
  TPST%NSTATE_IND(:,:) = -1
  TPST%NSTATE_IND_P(:,:) = -1
  TPST%NSTATE_LON(:) = -1
  TPST%NSTATE_LAT(:) = -1
  IPROCCELLS(:) = 0
  DO JNUM = 1,INCELLS
    JLON = ISTATE_LON_TMP(JNUM)
    JLAT = ISTATE_LAT_TMP(JNUM)
    JPROC = IBASPROC(TPG%NBASID(JLON,JLAT))
    IPROCCELLS(JPROC) = IPROCCELLS(JPROC)+1
    JSTATE = TPST%NSTATE_POS(JPROC)+IPROCCELLS(JPROC)-1
    TPST%NSTATE_IND(JLON,JLAT)   = JSTATE
    TPST%NSTATE_IND_P(JLON,JLAT) = JSTATE-TPST%NSTATE_POS(JPROC)+1
    TPST%NSTATE_LON(JSTATE) = JLON
    TPST%NSTATE_LAT(JSTATE) = JLAT
    IF(TPG%GMASK_LAKE_NW(JLON,JLAT))THEN
      TPST%NLAKE_STATE(TPLK%NLAKE_ID_NW(JLON,JLAT)) = JSTATE
    ENDIF
  ENDDO
  !
  ! Assign same state for all pixels of same lake
  DO JLAT = 1,KLAT
    DO JLON = 1,KLON
      IF(TPG%GMASK_LAKE_NW(JLON,JLAT))THEN
        JPROC = IBASPROC(TPG%NBASID(JLON,JLAT))
        TPST%NSTATE_IND(JLON,JLAT)   = TPST%NLAKE_STATE(TPLK%NLAKE_ID_NW(JLON,JLAT))
        TPST%NSTATE_IND_P(JLON,JLAT) = TPST%NSTATE_IND(JLON,JLAT)-TPST%NSTATE_POS(JPROC)+1
      ENDIF
    ENDDO
  ENDDO
  !
  WRITE(KLISTING,*) 'Total number of cells',INCELLS
  WRITE(KLISTING,*) 'Number of cells for each proc',TPST%NSTATE_LEN
  !
  DEALLOCATE(IBASCELLS)
  DEALLOCATE(IPROCCELLS)
  DEALLOCATE(IBASPROC)
  DEALLOCATE(ISTATE_LON_TMP)
  DEALLOCATE(ISTATE_LAT_TMP)
  DEALLOCATE(LLAKE_OUT)
  !
ENDIF
!
! --------------------------------------------------------------------------------------
! * 2. Broadcast to other procs
! --------------------------------------------------------------------------------------
!
CALL WAITING_MPI('TRIP_BASIN_PROC')
!
CALL MPI_BCAST(TPST%NNSTATE_P,1,MPI_INTEGER,NPIO,NCOMM,IERR)
!
ALLOCATE(TPST%NSTATE_LON_P(TPST%NNSTATE_P))
ALLOCATE(TPST%NSTATE_LAT_P(TPST%NNSTATE_P))
!
CALL MPI_BCAST(TPST%NSTATE_LEN,NPROC,MPI_INTEGER,NPIO,NCOMM,IERR)
TPST%NSTATE_LEN_P = TPST%NSTATE_LEN(NRANK)
CALL MPI_BCAST(TPST%NSTATE_IND_P,KLON*KLAT,MPI_INTEGER,NPIO,NCOMM,IERR)
CALL MPI_SCATTER(TPST%NSTATE_LON,TPST%NNSTATE_P,MPI_INTEGER, &
                 TPST%NSTATE_LON_P,TPST%NNSTATE_P,MPI_INTEGER,NPIO,NCOMM,IERR)
CALL MPI_SCATTER(TPST%NSTATE_LAT,TPST%NNSTATE_P,MPI_INTEGER, &
                 TPST%NSTATE_LAT_P,TPST%NNSTATE_P,MPI_INTEGER,NPIO,NCOMM,IERR)
!
IF (LHOOK) CALL DR_HOOK('TRIP_BASIN_PROC',1,ZHOOK_HANDLE)
!
END SUBROUTINE
